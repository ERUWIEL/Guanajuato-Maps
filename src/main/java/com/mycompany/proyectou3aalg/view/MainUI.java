package com.mycompany.proyectou3aalg.view;

import com.mycompany.proyectou3aalg.algorithms.BFS;
import com.mycompany.proyectou3aalg.algorithms.DFSRecorrido;
import com.mycompany.proyectou3aalg.algorithms.DijkstraRecorrido;
import com.mycompany.proyectou3aalg.algorithms.Kruskal_MST_Recorrido;
import com.mycompany.proyectou3aalg.util.Arista;
import com.mycompany.proyectou3aalg.util.Ciudad;
import com.mycompany.proyectou3aalg.util.Grafo;
import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.Arrays;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Héctor Alonso 252039
 * @author Erubiel Flores
 *
 * Clase que genera la interfaz gráfica del programa
 */
public class MainUI extends javax.swing.JFrame {

    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(MainUI.class.getName());
    private Grafo grafoActual;
    private GrafoPanel panel;

    /**
     * Creates new form MainUI
     */
    public MainUI() {
        initComponents();
        setLayout(new BorderLayout());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jMenuBar1 = new javax.swing.JMenuBar();
        menuFuncionalidad = new javax.swing.JMenu();
        subMenuRecorridos = new javax.swing.JMenu();
        btnrecorridoBFS = new javax.swing.JMenuItem();
        btnRecorridoDFS = new javax.swing.JMenuItem();
        btnMST = new javax.swing.JMenuItem();
        btnRutaMásCorta = new javax.swing.JMenuItem();
        menuOtros = new javax.swing.JMenu();
        btnTablaNA = new javax.swing.JMenuItem();
        btnReporteComplejidad = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Guanajuato Maps");

        menuFuncionalidad.setText("Funcionalidades");

        subMenuRecorridos.setText("Recorridos");

        btnrecorridoBFS.setText("BFS");
        btnrecorridoBFS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnrecorridoBFSActionPerformed(evt);
            }
        });
        subMenuRecorridos.add(btnrecorridoBFS);

        btnRecorridoDFS.setText("DFS");
        btnRecorridoDFS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRecorridoDFSActionPerformed(evt);
            }
        });
        subMenuRecorridos.add(btnRecorridoDFS);

        menuFuncionalidad.add(subMenuRecorridos);

        btnMST.setText("MST");
        btnMST.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMSTActionPerformed(evt);
            }
        });
        menuFuncionalidad.add(btnMST);

        btnRutaMásCorta.setText("Ruta más corta");
        btnRutaMásCorta.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRutaMásCortaActionPerformed(evt);
            }
        });
        menuFuncionalidad.add(btnRutaMásCorta);

        jMenuBar1.add(menuFuncionalidad);

        menuOtros.setText("Otros");

        btnTablaNA.setText("Tabla Nodos-Aristas");
        btnTablaNA.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnTablaNAActionPerformed(evt);
            }
        });
        menuOtros.add(btnTablaNA);

        btnReporteComplejidad.setText("Reporte de complejidad");
        btnReporteComplejidad.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnReporteComplejidadActionPerformed(evt);
            }
        });
        menuOtros.add(btnReporteComplejidad);

        jMenuBar1.add(menuOtros);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 640, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 457, Short.MAX_VALUE)
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void btnReporteComplejidadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnReporteComplejidadActionPerformed
        // TODO add your handling code here:
        
        JFrame ventana = new JFrame("Complejidad Temporal de Algoritmos Implementados");
        ventana.setSize(500, 600);

        ventana.setLocationRelativeTo(null);
        

        // Datos de la tabla
        String[] columnas = {"Algoritmo", "Complejidad Temporal"};
        Object[][] datos = {
            {"BFS", "O(V + E)"},
            {"DFS", "O(V + E)"},
            {"Kruskal", "O(E log E)"},
            {"Dijkstra", "O((V + E) log V)"}
        };

        // Modelo de tabla
        DefaultTableModel modelo = new DefaultTableModel(datos, columnas);
        JTable tabla = new JTable(modelo);

        // Ajustes visuales
        tabla.setFont(new Font("Arial", Font.PLAIN, 14));
        tabla.setRowHeight(25);
        tabla.getTableHeader().setFont(new Font("Arial", Font.BOLD, 14));

        // Scroll para la tabla
        JScrollPane scrollPane = new JScrollPane(tabla);
        ventana.add(scrollPane, BorderLayout.CENTER);
     
        ventana.setVisible(true);
        
    }//GEN-LAST:event_btnReporteComplejidadActionPerformed

    private void btnRecorridoDFSActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRecorridoDFSActionPerformed
        if (grafoActual == null) {
            JOptionPane.showMessageDialog(this, "No hay grafo inicializado", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        String[] nombresCiudades = grafoActual.getCiudades().stream()
                .map(c -> c.getNombre())
                .toArray(String[]::new);

        String ciudadSeleccionada = (String) JOptionPane.showInputDialog(
                this,
                "Selecciona la ciudad inicial para el recorrido DFS:",
                "Recorrido DFS",
                JOptionPane.QUESTION_MESSAGE,
                null,
                nombresCiudades,
                nombresCiudades[0]
        );

        if (ciudadSeleccionada != null) {
            Ciudad inicio = grafoActual.getCiudades().stream()
                    .filter(c -> c.getNombre().equals(ciudadSeleccionada))
                    .findFirst()
                    .orElse(null);

            if (inicio != null) {
                // Ejecutar BFS
                DFSRecorrido dfs = new DFSRecorrido(grafoActual, panel);
                dfs.ejecutarDesde(inicio);

            }
        }


    }//GEN-LAST:event_btnRecorridoDFSActionPerformed

    private void btnrecorridoBFSActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnrecorridoBFSActionPerformed
        if (grafoActual == null) {
            JOptionPane.showMessageDialog(this, "No hay grafo inicializado", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        String[] nombresCiudades = grafoActual.getCiudades().stream()
                .map(c -> c.getNombre())
                .toArray(String[]::new);

        String ciudadSeleccionada = (String) JOptionPane.showInputDialog(
                this,
                "Selecciona la ciudad inicial para el recorrido BFS:",
                "Recorrido BFS",
                JOptionPane.QUESTION_MESSAGE,
                null,
                nombresCiudades,
                nombresCiudades[0]
        );

        if (ciudadSeleccionada != null) {
            Ciudad inicio = grafoActual.getCiudades().stream()
                    .filter(c -> c.getNombre().equals(ciudadSeleccionada))
                    .findFirst()
                    .orElse(null);

            if (inicio != null) {
                // Ejecutar BFS con visualización
                BFS bfs = new BFS(grafoActual, panel);
                bfs.ejecutarDesde(inicio);
            }
        }
    }//GEN-LAST:event_btnrecorridoBFSActionPerformed

    private void btnMSTActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMSTActionPerformed
        Kruskal_MST_Recorrido mstk = new Kruskal_MST_Recorrido(grafoActual, panel);
        mstk.ejecutar();
    }//GEN-LAST:event_btnMSTActionPerformed

    private void btnRutaMásCortaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRutaMásCortaActionPerformed
        if (grafoActual == null) {
            JOptionPane.showMessageDialog(this, "No hay grafo inicializado", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        String[] nombresCiudades = grafoActual.getCiudades().stream()
                .map(c -> c.getNombre())
                .toArray(String[]::new);

        // Selección de origen
        String ciudadInicio = (String) JOptionPane.showInputDialog(
                this,
                "Selecciona la ciudad inicial:",
                "Cálculo de ruta más corta",
                JOptionPane.QUESTION_MESSAGE,
                null,
                nombresCiudades,
                nombresCiudades[0]
        );

        if (ciudadInicio != null) {

            Ciudad origen = grafoActual.getCiudades().stream()
                    .filter(c -> c.getNombre().equals(ciudadInicio))
                    .findFirst()
                    .orElse(null);

            // Selección de destino
            String ciudadDestino = (String) JOptionPane.showInputDialog(
                    this,
                    "Selecciona la ciudad destino:",
                    "Cálculo de ruta más corta",
                    JOptionPane.QUESTION_MESSAGE,
                    null,
                    nombresCiudades,
                    nombresCiudades[0]
            );

            Ciudad destino = grafoActual.getCiudades().stream()
                    .filter(c -> c.getNombre().equals(ciudadDestino)) // ← CORRECTO
                    .findFirst()
                    .orElse(null);

            if (origen != null && destino != null) {
                DijkstraRecorrido dijkstra = new DijkstraRecorrido(grafoActual, panel, origen, destino);
                dijkstra.ejecutarDijkstra();
            }
        }
    }//GEN-LAST:event_btnRutaMásCortaActionPerformed

    private void btnTablaNAActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnTablaNAActionPerformed
        // TODO add your handling code here:
        JFrame ventana = new JFrame("Complejidad Temporal de Algoritmos Implementados");
        ventana.setSize(500, 600);

        ventana.setLocationRelativeTo(null);
        
        //Encabezado
        String[] columnas = new String[grafoActual.getCiudades().size() + 1];
        columnas[0] = "Ciudades";
        for (int i = 0; i < grafoActual.getCiudades().size(); i++) {
            columnas[i + 1] = grafoActual.getCiudades().get(i).getNombre();
        }
        //Inicializar matriz 
        int[][] matrizPesos = new int[30][30];
        for (int i = 0; i < 30; i++) {
            Arrays.fill(matrizPesos[i], Integer.MAX_VALUE);
            matrizPesos[i][i] = 0; // distancia a sí mismo = 0
        }
        
        for(Arista a: grafoActual.getAristas()){
            int i = grafoActual.getCiudades().indexOf(a.getOrigen());
            int j = grafoActual.getCiudades().indexOf(a.getDestino());
            if (i != -1 && j != -1) {
                matrizPesos[i][j] = a.getPeso();
                matrizPesos[j][i] = a.getPeso(); //Por ser grafo no dirigido
            }
        }
        
        Object[][] datos = new Object[30][30 + 1];
        for (int i = 0; i < 30; i++) {
            datos[i][0] = grafoActual.getCiudades().get(i).getNombre();
            for (int j = 0; j < 30; j++) {
                datos[i][j + 1] = (matrizPesos[i][j] == Integer.MAX_VALUE) ? "0" : matrizPesos[i][j];
            }
        }

        // Crear modelo y tabla
        DefaultTableModel modelo = new DefaultTableModel(datos, columnas);
        JTable tabla = new JTable(modelo);
        tabla.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        
        for (int i = 0; i < tabla.getColumnCount(); i++) {
            tabla.getColumnModel().getColumn(i).setPreferredWidth(120); // ancho fijo
        }

        // Ajustes visuales
        tabla.setFont(new Font("Arial", Font.PLAIN, 12));
        tabla.setRowHeight(20);
        tabla.getTableHeader().setFont(new Font("Arial", Font.BOLD, 12));
        
        
        JScrollPane scrollPane = new JScrollPane(tabla, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, 
                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        ventana.add(scrollPane, BorderLayout.CENTER);
        
        ventana.setVisible(true);
        
    }//GEN-LAST:event_btnTablaNAActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem btnMST;
    private javax.swing.JMenuItem btnRecorridoDFS;
    private javax.swing.JMenuItem btnReporteComplejidad;
    private javax.swing.JMenuItem btnRutaMásCorta;
    private javax.swing.JMenuItem btnTablaNA;
    private javax.swing.JMenuItem btnrecorridoBFS;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenu menuFuncionalidad;
    private javax.swing.JMenu menuOtros;
    private javax.swing.JMenu subMenuRecorridos;
    // End of variables declaration//GEN-END:variables

    /**
     * Método que crea un grafo a partir de una matriz de adyacencias y un arreglo de nombres de ciudades
     * @param nombres
     * @param matrizAristas
     * @return 
     */
    public Grafo inicializarCiudadesYGrafo(String[] nombres, int[][] matrizAristas) {
        Grafo grafo = new Grafo();
        //Crea un arreglo de ciudades
        Ciudad[] ciudades = new Ciudad[30];
        //Ciclo que crea objetos ciudad, los añade al arreglo ciudades
        // y al grafo.
        for (int i = 0; i < nombres.length; i++) {
            ciudades[i] = new Ciudad(i, nombres[i]);
            grafo.agregarCiudad(ciudades[i]);

        }
        //Ciclo Matriz de Adyacencias
        for (int i = 0; i < 30; i++) { //recorre ciudades origen
            for (int j = 0; j < 30; j++) { // recorre ciudades destino
                if (matrizAristas[i][j] > 0) {
                    grafo.agregarArista(ciudades[i], ciudades[j], matrizAristas[i][j]);
                }
            }
        }
        this.grafoActual = grafo;
        return grafo;
    }
    /**
     * Método que crea posiciones en pixeles para los nodos del grafo a partir de una matriz con coordenadas geográficas
     * aproximadas.
     * @param coordenadas
     * @return 
     */
    //Genera posiciones para el Jframe que simulan la geografía del estado de Guanajuato
    public int[][] generarPosiciones(double[][] coordenadas) {
        //Convertir coordenadas geograficas a pixeles
        int[][] posiciones = new int[coordenadas.length][2];
        double minLat = 20.0, maxLat = 21.5;
        double minLon = -102.0, maxLon = -100.3;

        for (int i = 0; i < coordenadas.length; i++) {
            double lat = coordenadas[i][0];
            double lon = coordenadas[i][1];
            int x = (int) ((lon - minLon) / (maxLon - minLon) * 1000);
            int y = (int) ((maxLat - lat) / (maxLat - minLat) * 700);
            posiciones[i][0] = x;
            posiciones[i][1] = y;
        }

        //Aplicar separación minima entre nodos 
        for (int i = 0; i < posiciones.length; i++) {
            for (int j = i + 1; j < posiciones.length; j++) {
                int dx = posiciones[i][0] - posiciones[j][0];
                int dy = posiciones[i][1] - posiciones[j][1];
                double distancia = Math.sqrt(dx * dx + dy * dy);
                if (distancia < 30) { // mínimo 30 píxeles
                    posiciones[j][0] += 20;
                    posiciones[j][1] += 20;
                }
            }
        }

        return posiciones;
    }
    
    public void setPanel(GrafoPanel panel) {
        this.panel = panel;
    }

}
